Linux Device Driver Polling Mechanism Guide
===========================================

Core Concept
------------
Polling in Linux device drivers refers to supporting the `poll()` or `select()` system calls. 
These calls allow a userspace program to efficiently monitor multiple file descriptors (sockets, files, devices) and
sleep until at least one becomes "ready" (readable, writable, or has an error). This is NOT busy-waiting; 
it's an efficient sleep/wakeup mechanism.

------------------
Without `poll()`, a program waiting for an event (like a button press) would have to:
1. Busy-wait: Constantly check in a loop, wasting 100% of a CPU core.
2. Sleep-and-check: Use `sleep()` between checks, introducing latency.

The `poll()` system call solves this by allowing the process to sleep indefinitely until the driver explicitly
 wakes it up when data is available. This is both efficient (0% CPU usage while sleeping) and responsive 
 (instant wakeup on event).

Key Components Needed for Polling
---------------------------------

1. Wait Queue (`wait_queue_head_t`)
   - What: A kernel data structure that manages a list of sleeping processes.
   - Why: Provides a "waiting room" where processes that call `poll()` are put to sleep when no data is available.
   - How:
        Declaration: `static wait_queue_head_t my_waitqueue;`
        Initialization: `init_waitqueue_head(&my_waitqueue);` (in module init)

2. Flag Variable (`int`)
   - What: A simple variable that indicates the device state.
   - Why: Serves as a communication link between the Interrupt Service Routine (ISR) and the poll function.
   - How:
        Declaration: `static int irq_ready = 0;`
        Usage: 
            - ISR sets it to 1 when event occurs
            - Poll function checks it and clears it after event handling

3. Interrupt Service Routine (ISR)
   - What: Function called by kernel in response to hardware events.
   - Why: Detects hardware events and triggers the wakeup mechanism.
   - Responsibilities:
        a. Set the flag: `irq_ready = 1;`
        b. Wake processes: `wake_up(&my_waitqueue);`
   - Constraints: Runs in interrupt context - must be fast and cannot sleep.

4. Poll Function (in file_operations)
   - What: The `.poll` function in your driver's file_operations structure.
   - When called: By kernel when userspace calls `poll()`/`select()` on your device.
   - Responsibilities:
        a. Register wait queue: `poll_wait(file, &my_waitqueue, wait);`
        b. Check device state: Examine flag variable
        c. Return status: 
            - Return `POLLIN` if data available
            - Return `0` if no data available (causes process to sleep)

Complete Execution Flow
-----------------------
1. Initial State: Device idle, flag = 0, wait queue empty.

2. Userspace Calls Poll: Program calls `poll(fd, ...)` on device file.

3. Kernel Invokes Driver Poll:
   - Driver calls `poll_wait()` to register the wait queue
   - Driver checks flag, finds it = 0
   - Driver returns 0 to kernel
   - Kernel puts process to sleep on the wait queue

4. Hardware Event Occurs: Button pressed, GPIO state changes.

5. Hardware Interrupt: CPU jumps to kernel interrupt handler.

6. Kernel Calls Your ISR:
   - ISR sets flag: `irq_ready = 1;`
   - ISR wakes queue: `wake_up(&my_waitqueue);`
   - ISR returns

7. Process Woken: Kernel moves sleeping process to runnable state.

8. Poll Re-checked: Kernel re-enters driver's poll function.

9. Driver Finds Event:
   - Driver checks flag, finds it = 1
   - Driver clears flag: `irq_ready = 0;` (for next event)
   - Driver returns `POLLIN` to kernel

10. Poll Returns: Userspace `poll()` call returns, indicating device is readable.

11. Userspace Reads Data: Program can now call `read()` to get the event data.

GPIO-Specific Implementation Details
------------------------------------
For a GPIO button driver, you additionally need:

1. GPIO Setup:
   - Validate GPIO: `gpio_is_valid(GPIO_NUM)`
   - Request GPIO: `gpio_request(GPIO_NUM, "label")`
   - Set direction: `gpio_direction_input(GPIO_NUM)`
   - Export (optional): `gpio_export(GPIO_NUM, false)`

2. IRQ Setup:
   - Map GPIO to IRQ: `irq_number = gpio_to_irq(GPIO_NUM)`
   - Request IRQ: `request_irq(irq_number, handler, flags, "name", NULL)`
   - IRQ flags should match hardware behavior: 
        `IRQF_TRIGGER_RISING` (press)
        `IRQF_TRIGGER_FALLING` (release)
        `IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING` (both)

3. Character Device Setup:
   - Register device: `register_chrdev(major, "name", &fops)`
   - File operations must include `.poll` handler

Cleanup Requirements
--------------------
When unloading module, must release all resources in reverse order:
1. Free IRQ: `free_irq(irq_number, NULL)`
2. Unexport GPIO: `gpio_unexport(GPIO_NUM)`
3. Free GPIO: `gpio_free(GPIO_NUM)`
4. Unregister device: `unregister_chrdev(major, "name")`

Advantages of This Approach
---------------------------
- Zero CPU usage while waiting for events
- Instant response to hardware events
- Supports multiple processes waiting simultaneously
- Standard Linux API familiar to application developers
- Scalable to handle multiple event sources

Typical Use Cases
-----------------
- GPIO button/switch interfaces
- Sensors with interrupt capabilities
- Custom hardware with event-based signaling
- Any device where efficient waiting is preferred over periodic checking