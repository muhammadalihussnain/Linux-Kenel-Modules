BMP280 SPI Driver Overview

The BMP280 is a digital pressure and temperature sensor that communicates with a host controller via SPI or I²C. In SPI mode, 
the host CPU or microcontroller acts as the master, and the BMP280 acts as a slave device. Each register in the BMP280 has a
specific address defined in the datasheet, and these registers store information or control settings for the sensor. For instance,
the CHIP_ID register (0xD0) holds a unique value that identifies the sensor, which allows the software to verify that the correct
device is connected. To read this register, the driver sets up a transmit byte where the MSB is set to 1, indicating a read
operation, and sends it over SPI. The value returned by the sensor is then captured into a variable for verification. Similarly,
the CONFIG register (0xF5) is used to configure the sensor's standby time and IIR filter settings, while the CTRL_MEAS 
register (0xF4) controls oversampling settings for temperature and pressure measurements and sets the power mode of the device 
(e.g., sleep, forced, or normal). Writing to these registers requires setting the MSB of the register address to 0, indicating 
a write operation, and sending the desired configuration value along with the address.

To read measurement data, the BMP280 stores raw pressure and temperature values across six consecutive registers, from 0xF7 to 0xFC.
The reading mechanism involves sending the starting register address with the read bit set (MSB = 1) and then performing a sequential
read of six bytes. Each byte corresponds to a portion of the 20-bit raw pressure or temperature data. In the driver, this is 
achieved using the spi_write_then_read() function, which handles both sending the register address and reading back the sensor data
in a single atomic operation. This ensures that the SPI bus is properly managed and that the data returned corresponds exactly to
the requested registers. After reading, the bytes are combined and shifted appropriately to reconstruct the 20-bit raw values,
which can then be converted into physical pressure and temperature readings using the compensation formulas provided in the
BMP280 datasheet.

The overall process of interacting with the BMP280, therefore, involves three key steps: initializing the SPI master and creating
a device instance, writing configuration values to the relevant control registers, and reading back chip identification and
measurement data. Each of these steps relies on understanding the sensor datasheet, correctly setting the SPI read/write bits, 
and using Linux kernel SPI APIs such as spi_busnum_to_master(), spi_new_device(), spi_setup(), spi_write(), and 
spi_write_then_read(). By following this procedure, the driver ensures reliable communication with the BMP280, properly configures
the sensor, and accurately retrieves sensor data for further processing.

---

General Notes on Reading/Writing Registers of Any Device (SPI/I²C):

1. Understanding the Datasheet:
   - Always check the device datasheet to know register addresses, bit fields, and read/write procedures.
   - Each register has a specific purpose (control, status, or data).

2. Read Operations:
   - For SPI devices, set the MSB or a specific read bit if required by the device.
   - For I²C devices, the master typically sends the register address and then reads the response bytes.
   - Use sequential reads if multiple consecutive registers hold relevant data.

3. Write Operations:
   - Clear the read bit (or set write bit) in SPI, or use normal write in I²C.
   - Send the register address followed by the value to be written.
   - Some registers may require multiple bytes for configuration.

4. Data Handling:
   - Multi-byte registers often need byte-wise combination and shifting to reconstruct full values (e.g., 16-bit or 20-bit data).
   - Apply any device-specific scaling or compensation formulas as described in the datasheet.

5. API Usage (Linux kernel):
   - SPI: spi_busnum_to_master(), spi_new_device(), spi_setup(), spi_write(), spi_write_then_read().
   - I²C: i2c_new_device(), i2c_smbus_read_byte_data(), i2c_smbus_write_byte_data().

6. Best Practices:
   - Always verify device presence using CHIP_ID or WHO_AM_I registers.
   - Configure control registers before reading data.
   - Use proper delays or wait for ready flags if required.
   - Handle errors from SPI/I²C operations.

This note serves as a quick reference for programming drivers and communicating with any sensor or peripheral using register-based protocols.